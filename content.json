[{"title":"react-native学习笔记1","date":"2017-10-24T10:01:59.000Z","path":"2017/10/24/rn-learn1/","text":"最近开始接触react-native，把自己学习这门技术的过程记录下来，也避免以后遇到类似的坑。其实会react，上手RN并不难，难的是其中原生的东西以及配置和使用中各种各样的陷阱。 今天重新写博客的时候，执行hexo new命令突然报了一个错，在以前是从没见过的：1&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125; 不过页面还是会创建，网上看了原因之后，在项目下执行： 1npm install hexo --no-optional 问题解决，不行的话就重新装一次hexo-cli： 12npm uninstall hexo-cli -gnpm install hexo-cli -g 其实在写RN的时候也会遇到各种各样的奇葩问题，慢慢解决才能够成长。 初识react-native在学校的时候就听过react-native的大名，当时在实习用的是ng的技术栈就没有深入去了解(并不是技术狂啊-_-)。 简单来说，react-native的思想就是： Learn once, write anywhere 学习一次，在任何平台上编写。至少现在来说是很有用的，对技术人员是技术上的拓展，对公司而言，不用招专门的android或者iOS开发人员，控制成本。react-native由Facebook出品，前端人员学习起来应该比较容易，熟悉ES6语法，懂一点react，结合官方文档几天就可以上手。安卓开发人员可能要难一点，ES6和react就要花点时间了。 推荐使用mac来开发，因为现在只支持在mac上面开发iOS，windows上能不能装一个虚拟机来开发还没试过。不过如果你不需要iOS应用的话，windows也是一个不错的选择。 环境搭建首先搭建iOS开发环境，在Mac上面很方便就搭建好了。假设你已经在你的 Mac上装好了Homebrew，nodejs等工具，那么就开始安装react-native-cli，这是用于执行创建、初始化、更新项目、运行打包服务（packager）等任务的工具，很强大。1npm install -g react-native-cli 也可以使用yarn来代替npm，不过语法可能不太相同，我觉得网络允许的情况下看个人喜好：1npm install -g yarn 安装好之后，需要在Mac上安装Xcode，运行iOS必不可少的软件，可以在App Store上面直接下载，比较大，需要一点时间下载。还有一些官方推荐下载的工具，比如：watchman，flow，nuclide等，具体可以看文档。至于编辑器或者IDE，webstorm，sublime，vs code都可以选择，这个就自己选择了。 iOS环境基本就是这样，Xcode实在是省事，而且还自带模拟器。接下来搭建android开发环境： 官方推荐使用Android studio来开发，如果需要可以按照文档来下载安装，版本要在2.0以上。也可以不要这个软件，需要下载Android SDK，JDK，还要配置ANDROID_HOME环境变量，下载好依赖之后在~/.bash_profile文件中配置，如果没有此文件就创建一个。可以使用open命令来打开文件。比如：1open ~/.bash_profile 此文件的配置如图：其中，配置你的javahome和androidhome，分别指向你电脑上的jdk路径和Androidsdk路径。完成之后，android环境也完成了，就可以创建项目来试试。 新建项目使用react-native-cli工具来快速生成项目：1react-native init appName 需要注意的是，使用init命令创建默认使用的是react和react-native的最新版本。由于react-native在0.45之后需要boost库编译，这个库庞大且需要翻墙，所以如果没那么大的需求需要用最新版本，可以用0.44.3的版本：1react-native init appName --version 0.44.3 那么就会使用react-native的0.44.3的版本。执行完命令之后需要等待一段时间，此期间会下载很多依赖，项目创建完成之后是这样的：我使用的是vs code编辑器，其中android文件夹和iOS文件夹分别是两种平台的东西，一般写原生的东西才需要。app文件夹是自己创建的，在这里写组件和逻辑样式那些，主要在这里操作。index.android.js和index.ios.js是程序开始运行的地方，需要注意的是里面1AppRegistry.registerComponent(&apos;appName&apos;, () =&gt; appName); 第一个appName是执行init命令时命名的名字，必须保持一致，否则无法运行。 运行项目接下来就可以运行项目了，对于iOS执行命令1react-native run-ios 等待一些时间，就会弹出iOS模拟器，也可以在Xcode上打开.xcodeproj文件，点击run按钮运行，还可以选择不同的iPhone来测试。 Mac上cmd+r刷新页面，cmd+d打开一个菜单，包括 Reload Debug JS Remotely Enable Live Reload Enable Hot Reloading Toggle Inspector Show Perf Monitor Start/Stop Sampling Profiler Dev Settings Reload是重新加载，第二个是在浏览器里面调试，还有其他热更新和设置等。 对于android，运行命令：1react-native run-android 按惯例，等待一段时间，会提示你错误，原因是iOS是Mac自带模拟器，android要么下一个模拟器，要么连接自己的手机(android系统的)。连接自己的手机需要开发者权限，可以使用命令1adb devices 来查看是否连接上了手机。 假设使用手机，运行run-android之后，就会在手机上装一个以你项目名命名的app，可以修改名字和图标，在android文件夹下面的app/src/res，其中values文件夹改名字，其它文件夹改图标。 安装后app之后，打开发现白屏了，此时需要打开app的悬浮窗权限，再次打开就运行正常了。我遇到过端口占用的情况，默认是8081端口，可以修改端口来预防错误：1react-native start --port xxxx 这个xxxx就是你自己想用的端口号。现在的模式是USB连接手机，不使用USB需要保证电脑和手机在同一局域网，并且需要在Dev Settings里面设置Debugging，里面填写局域网的IP地址，还要加上端口号，如果你没修改就是8081，改了就是修改之后的端口。 现在为止，断开USB，重新打开app，摇一摇手机就可以看到刚才那个菜单，将IP设置好，以后就可以用1npm start 来运行app。 结语这是我自己学习react-native的第一篇，参考了官方文档和自己搭建所遇到的坑，主要是环境搭建和项目创建运行，以后会慢慢写自己使用中的想法和问题。 参考： 官方文档","tags":[{"name":"--react-native","slug":"react-native","permalink":"https://sixcx.github.io/tags/react-native/"}]},{"title":"webpack学习","date":"2017-09-13T03:48:51.000Z","path":"2017/09/13/webpack/","text":"作为一款模块加载器和打包工具，webpack能帮助我们把把各种资源作为模块来处理和使用。掌握其使用会为我们在构建项目时省去大量的时间，在前端工程化的今天，webpack是每个前端都要去学习和掌握的。 webpack的优势从一个或多个入口文件开始，webpack从此开始找到项目所依赖的文件，打包成一个或多个js文件。webpack是一个模块化的处理方案，我们无需去寻找文件所在位置，webpack会将所有的依赖加载，个更加方便。 相比于gulp/grunt，webpack也可以实现相同的工作，比如打包，压缩，混淆，图片处理等。 entry配置entry是webpack配置的入口文件，可以配置单入口和多入口： 12345678910111213141516//单入口配置entry: __dirname + &quot;/app/main.js&quot;//也可以是entry: &#123; main: __dirname + &quot;/app/main.js&quot;&#125;//支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出entry: &#123; main: [&quot;./entry1&quot;, &quot;./entry2&quot;]&#125;//多入口配置entry: &#123; pageOne: &apos;./src/pageOne/index.js&apos;, pageTwo: &apos;./src/pageTwo/index.js&apos;, pageThree: &apos;./src/pageThree/index.js&apos;&#125; output配置12345678910111213//通常情况下&#123; entry: &#123; app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, path: __dirname + &apos;/dist&apos; &#125;&#125;// 结果: ./dist/app.js, ./dist/search.js 关于publicPath(虚拟路径)：如果有域名或者打算用CDN，可以使用这个配置。使用了这个配置，本地资源路径会被替换成publicPath所指定的地址。 12345output: &#123; path: &quot;/home/proj/cdn/assets/&quot;, publicPath: &quot;http://cdn.example.com/assets/&quot;, filename:&apos;[name].js&apos;&#125; 关于filename：决定了每个输出的名称，将写到path指定的目录下。对于单个入口起点，filename 会是一个静态名称。 1filename: &quot;bundle.js&quot; 然而，当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个 bundle，应该使用以下一种替换方式，来赋予每个 bundle 一个唯一的名称。 使用入口名称： 1filename: &quot;[name].bundle.js&quot; 使用内部 chunk id 1filename: &quot;[id].bundle.js&quot; 使用每次构建过程中，唯一的 hash 生成 1filename: &quot;[name].[hash].bundle.js&quot; 使用基于每个 chunk 内容的 hash(内容不变值不变)： 1filename: &quot;[chunkhash].bundle.js&quot; Source Maps(方便调试)在配置文件中配置source maps，需要devtool，常用以下四种配置选项： devtool选项 结果 source-map 生产环境，显示源码，会减慢打包速度 cheap-module-source-map 生成一个不带列映射的map，提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列，对调试不便。 eval-source-map 在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项 cheap-module-eval-source-map 仅显示行，缺点与eval-source-map相同 对小到中型的项目中，eval-source-map是一个很好的选项，cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用 123module.exports = &#123; devtool: &apos;eval-source-map&apos;&#125; devServer(构建本地服务器)需要单独安装它作为项目依赖： 123456789npm install --save-dev webpack-dev-serverdevServer: &#123; contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true,//实时刷新 compress: true,//做 gzip 压缩 port: 9000//端口&#125; loaders创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。 每个规则可以分为三部分 - 条件(condition)，结果(result)和嵌套规则(nested rule)。 在具体使用时需要install，对应的使用方法可在使用时查看相关文档。 1234567891011121314151617181920212223242526module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: &quot;babel-loader&quot;, options: &#123; presets: [ &quot;es2015&quot;, &quot;react&quot; ] &#125; &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: &quot;style-loader&quot; &#125;, &#123; loader: &quot;css-loader&quot; &#125; ] &#125; ] &#125; Plugins(插件)用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。 例如，当多个 bundle 共享一些相同的依赖，CommonsChunkPlugin 有助于提取这些依赖到共享的 bundle 中，来避免重复打包。可以像这样添加： 123456789101112131415161718192021222324252627282930313233plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; ... &#125;)]//具体例子// 在配置中添加插件plugins: [ // 构建优化插件 new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, filename: &apos;vendor-[hash].min.js&apos;, &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, drop_console: false, &#125; &#125;), new ExtractTextPlugin(&#123; filename: &apos;build.min.css&apos;, allChunks: true, &#125;), new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/), // 编译时(compile time)插件 new webpack.DefinePlugin(&#123; &apos;process.env.NODE_ENV&apos;: &apos;&quot;production&quot;&apos;, &#125;), // webpack-dev-server 强化插件 new DashboardPlugin(), new webpack.HotModuleReplacementPlugin(),] 常用插件： HtmlWebpackPlugin(生成一个自动引用你打包后的JS文件的新index.html,这在每次生成的js文件名称不同时非常有用) Hot Module Replacement(允许你在修改组件代码后，自动刷新实时预览修改后的效果) OccurenceOrderPlugin(为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID) UglifyJsPlugin(压缩JS) ExtractTextPlugin(分离CSS和JS文件) 有些是webpack自带的，还有些就需要install，并且根据相关文档进行配置。 解析(Resolve)resolve.alias：创建别名，来确保模块引入变得更简单： 1234alias: &#123; Utilities: path.resolve(__dirname, &apos;src/utilities/&apos;), Templates: path.resolve(__dirname, &apos;src/templates/&apos;)&#125; 使用： 1import Utility from &apos;Utilities/utility&apos;; 在给定对象的键后的末尾添加 $，以表示精准匹配： 123alias: &#123; xyz$: path.resolve(__dirname, &apos;path/to/file.js&apos;)&#125; 结果： 12import Test1 from &apos;xyz&apos;; // 精确匹配，所以 path/to/file.js 被解析和导入import Test2 from &apos;xyz/file.js&apos;; // 精确匹配，触发普通解析 这是webpack的常用的配置，可以应对平时大部分的项目，最好的方式还是结合gulp来使用，gulp构建更快，webpack是模块化的最好选择。 这算是自己的学习笔记吧，现在都会记录下来，回过头来看时想必会有收获的。 参考webpack3.5.5中文文档 入门Webpack，看这篇就够了","tags":[{"name":"-webpack -构建工具","slug":"webpack-构建工具","permalink":"https://sixcx.github.io/tags/webpack-构建工具/"}]},{"title":"js语法","date":"2017-02-14T13:18:47.000Z","path":"2017/02/14/js-grammar/","text":"基本语法语句js程序执行单位为行，一行一行的执行，一般来说，一行就是一条语句。语句(statement)是为了完成某种任务而进行的操作。比如： var a = 1 + 1; 1 + 1 为表达式(expression),为了得到返回值的计算式。语句与表达式区别为:语句一般不需要返回值，表达式一定会返回一个值。js语言中预期为值的地方都可以使用表达式，一条语句可以包含多个表达式。语句已分号结尾，一个分号就表示语句结束，分号前面可以没有内容，js引擎视为空语句。表达式不需要分号结尾，加分号则视为语句，无任何意义。 变量概念变量是对值的引用 var a = 1先声明a，再将两个数之间建立引用关系，就是将1赋值给a。var表示变量声明命令，通知解释引擎，创建一个变量a。实际上是: var a; a = 1; 只是声明变量不赋值，该变量的值是undefined.不写var也是有效的，不过会创建全局变量。 var a = 1和a = 1,这两条语句效果完全相同，严格来说本质不完全相同，只有var a= 1才是声明变量。a = 1相当于window[“a”] = 1.对象的属性可删除，所以可以delete a. 变量没有声明直接使用，就回报变量未定义。变量的类型没有限制，可以赋予各种类型的值，若声明一个存在的变量，第二次声明无效，赋值后会覆盖前面的值。 变量提升js引擎工作方式是先解析代码，获取所有被声明的变量，再一行一行的运行。结果就是所有变量的声明语句都会被提升到代码的头部，即为变量提升(hoisting)。比如: console.log(a); var a = 1; 实际上: var a; console.log(a); a = 1; 显示为undefined,不是用var声明的变量不会发生变量提升。 注：js有四种在作用域内获得提升的途径(优先级)：1.语言定义的声明，如this,arguments，不能在作用域内重新定义this2.形式参数3.函数声明4.var声明的变量 标识符用来识别具体对象的一个名称，最常见为变量名，以及函数名。命名规则:第一个字符可以是任意Unicode字母，$和_,第二个及以后的还可以用0-9中文可以用作标识符， js有一些保留字不能用作标识符:arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yieldInfinity NaN undefined虽然不是保留字，但因为具有特别含义，也不用作标识","tags":[{"name":"js","slug":"js","permalink":"https://sixcx.github.io/tags/js/"}]},{"title":"hexo搭建github博客的学习","date":"2017-02-14T12:09:22.000Z","path":"2017/02/14/hexo-learn/","text":"导语 使用github pages服务器搭建博客的好处:1.静态文件，访问速度快2.免费，无需花钱就能搭建一个自己的博客3.数据安全，基于github4.只需要写自己的文章上传即可5.可以随意绑定自己的域名 准备工作 自己的github账号 安装nodejs、npm，及其相关知识 安装git 创建仓库新建用户名为 username.github.io的仓库,username就是你的用户名，也必须是你的用户名，访问地址就是 http://username.github.io每个账号只能创建一个这样的可以直接访问的仓库，以后你的代码都放在这个仓库 绑定域名显然，不绑定也是可以的，如果你想有个性一点，就去注册一个域名。配置域名常见两种方式，CNAME和A记录，CNAME填域名，A记录填IP，不带www方式的只能采用A记录，先ping一下username.github.io的IP，到你的域名DNS设置页将A记录指向这个IP，将CNAME指向username.github.io，保证无论是否有www都能访问。到你项目的根目录建一个CNAME文件，填写你的域名，就可以访问这个域名，原来的默认并没有失效，只是自动调转到新域名 配置SSH key解决服务器与本机的连接问题，打开git bash执行: cd ~/.ssh #检查本机已存在的ssh密钥 提示: No such file of directory说明是第一次使用执行: ssh-keygen -t rsa -C &quot;你的邮件地址&quot; 3次回车，会生成在用户目录下，打开.ssh\\id_rsa.pub，复制内容，在你的github主页个人设置-&gt;SSH ang GPG keys-&gt;New SSH key，将内容复制进去，title随意，保存执行以下命令来测试是否成功: ssh -T git@github.com 若提示Are you sure yo want to continue connecting(yes/no)?，输入yes，成功 使用hexo简介:hexo是一个基于Github Pages的博客发布工具 官网：http://hexo.io github: https://github.com/hexojs/hexo安装： npm install -g hexo 初始化：新建一个文件夹，作为存放代码的地方 cd 你的文件夹 hexo init hexo会自动加载文件到此目录使用以下命令生成启动: hexo g #生成 hexo s #启动服务 执行后会在目录下生成public文件夹生成相关html文件，用于提交到github打开localhost:4000就会看到内容 修改主题：网上有很多，这里使用hexo-theme-yilia下载: git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 将主题放入theme文件夹下的yilia，修改根目录_config.yml的theme: landscape改为theme: yilia，执行hexo g 重新生成，遇到问题可以执行hexo clean来清理，再重新生成发布。 上传到github将_config_yml中的deploy修改: deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 安装下列插件: npm install hexo-deploy-git --save 使用git bash 输入 hexo d 将代码提交到github 可以将CNAME、README.md等文件放入source，在_config.yml中配置skip_render: [README.md] 缩写: hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令: hexo s -g #生成并本地预览 hexo d -g #生成并上传 写博客到hexo根目录执行: hexo new &apos;name&apos; hexo会帮我们在_posts下面生成相关md文件打开此文件就可以开始写博客","tags":[{"name":"github","slug":"github","permalink":"https://sixcx.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://sixcx.github.io/tags/hexo/"}]}]