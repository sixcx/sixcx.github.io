[{"title":"webpack学习","date":"2017-09-13T03:48:51.000Z","path":"2017/09/13/webpack/","text":"作为一款模块加载器和打包工具，webpack能帮助我们把把各种资源作为模块来处理和使用。掌握其使用会为我们在构建项目时省去大量的时间，在前端工程化的今天，webpack是每个前端都要去学习和掌握的。 webpack的优势从一个或多个入口文件开始，webpack从此开始找到项目所依赖的文件，打包成一个或多个js文件。webpack是一个模块化的处理方案，我们无需去寻找文件所在位置，webpack会将所有的依赖加载，个更加方便。 相比于gulp/grunt，webpack也可以实现相同的工作，比如打包，压缩，混淆，图片处理等。 entry配置entry是webpack配置的入口文件，可以配置单入口和多入口： 12345678910111213141516//单入口配置entry: __dirname + &quot;/app/main.js&quot;//也可以是entry: &#123; main: __dirname + &quot;/app/main.js&quot;&#125;//支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出entry: &#123; main: [&quot;./entry1&quot;, &quot;./entry2&quot;]&#125;//多入口配置entry: &#123; pageOne: &apos;./src/pageOne/index.js&apos;, pageTwo: &apos;./src/pageTwo/index.js&apos;, pageThree: &apos;./src/pageThree/index.js&apos;&#125; output配置12345678910111213//通常情况下&#123; entry: &#123; app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos;, path: __dirname + &apos;/dist&apos; &#125;&#125;// 结果: ./dist/app.js, ./dist/search.js 关于publicPath(虚拟路径)：如果有域名或者打算用CDN，可以使用这个配置。使用了这个配置，本地资源路径会被替换成publicPath所指定的地址。 12345output: &#123; path: &quot;/home/proj/cdn/assets/&quot;, publicPath: &quot;http://cdn.example.com/assets/&quot;, filename:&apos;[name].js&apos;&#125; 关于filename：决定了每个输出的名称，将写到path指定的目录下。对于单个入口起点，filename 会是一个静态名称。 1filename: &quot;bundle.js&quot; 然而，当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个 bundle，应该使用以下一种替换方式，来赋予每个 bundle 一个唯一的名称。 使用入口名称： 1filename: &quot;[name].bundle.js&quot; 使用内部 chunk id 1filename: &quot;[id].bundle.js&quot; 使用每次构建过程中，唯一的 hash 生成 1filename: &quot;[name].[hash].bundle.js&quot; 使用基于每个 chunk 内容的 hash(内容不变值不变)： 1filename: &quot;[chunkhash].bundle.js&quot; Source Maps(方便调试)在配置文件中配置source maps，需要devtool，常用以下四种配置选项： devtool选项 结果 source-map 生产环境，显示源码，会减慢打包速度 cheap-module-source-map 生成一个不带列映射的map，提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列，对调试不便。 eval-source-map 在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项 cheap-module-eval-source-map 仅显示行，缺点与eval-source-map相同 对小到中型的项目中，eval-source-map是一个很好的选项，cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用 123module.exports = &#123; devtool: &apos;eval-source-map&apos;&#125; devServer(构建本地服务器)需要单独安装它作为项目依赖： 123456789npm install --save-dev webpack-dev-serverdevServer: &#123; contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true,//实时刷新 compress: true,//做 gzip 压缩 port: 9000//端口&#125; loaders创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。 每个规则可以分为三部分 - 条件(condition)，结果(result)和嵌套规则(nested rule)。 在具体使用时需要install，对应的使用方法可在使用时查看相关文档。 1234567891011121314151617181920212223242526module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: &quot;babel-loader&quot;, options: &#123; presets: [ &quot;es2015&quot;, &quot;react&quot; ] &#125; &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: &quot;style-loader&quot; &#125;, &#123; loader: &quot;css-loader&quot; &#125; ] &#125; ] &#125; Plugins(插件)用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。 例如，当多个 bundle 共享一些相同的依赖，CommonsChunkPlugin 有助于提取这些依赖到共享的 bundle 中，来避免重复打包。可以像这样添加： 123456789101112131415161718192021222324252627282930313233plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; ... &#125;)]//具体例子// 在配置中添加插件plugins: [ // 构建优化插件 new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, filename: &apos;vendor-[hash].min.js&apos;, &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, drop_console: false, &#125; &#125;), new ExtractTextPlugin(&#123; filename: &apos;build.min.css&apos;, allChunks: true, &#125;), new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/), // 编译时(compile time)插件 new webpack.DefinePlugin(&#123; &apos;process.env.NODE_ENV&apos;: &apos;&quot;production&quot;&apos;, &#125;), // webpack-dev-server 强化插件 new DashboardPlugin(), new webpack.HotModuleReplacementPlugin(),] 常用插件： HtmlWebpackPlugin(生成一个自动引用你打包后的JS文件的新index.html,这在每次生成的js文件名称不同时非常有用) Hot Module Replacement(允许你在修改组件代码后，自动刷新实时预览修改后的效果) OccurenceOrderPlugin(为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID) UglifyJsPlugin(压缩JS) ExtractTextPlugin(分离CSS和JS文件) 有些是webpack自带的，还有些就需要install，并且根据相关文档进行配置。 解析(Resolve)resolve.alias：创建别名，来确保模块引入变得更简单： 1234alias: &#123; Utilities: path.resolve(__dirname, &apos;src/utilities/&apos;), Templates: path.resolve(__dirname, &apos;src/templates/&apos;)&#125; 使用： 1import Utility from &apos;Utilities/utility&apos;; 在给定对象的键后的末尾添加 $，以表示精准匹配： 123alias: &#123; xyz$: path.resolve(__dirname, &apos;path/to/file.js&apos;)&#125; 结果： 12import Test1 from &apos;xyz&apos;; // 精确匹配，所以 path/to/file.js 被解析和导入import Test2 from &apos;xyz/file.js&apos;; // 精确匹配，触发普通解析 这是webpack的常用的配置，可以应对平时大部分的项目，最好的方式还是结合gulp来使用，gulp构建更快，webpack是模块化的最好选择。 这算是自己的学习笔记吧，现在都会记录下来，回过头来看时想必会有收获的。 参考webpack3.5.5中文文档 入门Webpack，看这篇就够了","tags":[{"name":"-webpack -构建工具","slug":"webpack-构建工具","permalink":"https://sixcx.github.io/tags/webpack-构建工具/"}]},{"title":"js语法","date":"2017-02-14T13:18:47.000Z","path":"2017/02/14/js-grammar/","text":"基本语法语句js程序执行单位为行，一行一行的执行，一般来说，一行就是一条语句。语句(statement)是为了完成某种任务而进行的操作。比如： var a = 1 + 1; 1 + 1 为表达式(expression),为了得到返回值的计算式。语句与表达式区别为:语句一般不需要返回值，表达式一定会返回一个值。js语言中预期为值的地方都可以使用表达式，一条语句可以包含多个表达式。语句已分号结尾，一个分号就表示语句结束，分号前面可以没有内容，js引擎视为空语句。表达式不需要分号结尾，加分号则视为语句，无任何意义。 变量概念变量是对值的引用 var a = 1先声明a，再将两个数之间建立引用关系，就是将1赋值给a。var表示变量声明命令，通知解释引擎，创建一个变量a。实际上是: var a; a = 1; 只是声明变量不赋值，该变量的值是undefined.不写var也是有效的，不过会创建全局变量。 var a = 1和a = 1,这两条语句效果完全相同，严格来说本质不完全相同，只有var a= 1才是声明变量。a = 1相当于window[“a”] = 1.对象的属性可删除，所以可以delete a. 变量没有声明直接使用，就回报变量未定义。变量的类型没有限制，可以赋予各种类型的值，若声明一个存在的变量，第二次声明无效，赋值后会覆盖前面的值。 变量提升js引擎工作方式是先解析代码，获取所有被声明的变量，再一行一行的运行。结果就是所有变量的声明语句都会被提升到代码的头部，即为变量提升(hoisting)。比如: console.log(a); var a = 1; 实际上: var a; console.log(a); a = 1; 显示为undefined,不是用var声明的变量不会发生变量提升。 注：js有四种在作用域内获得提升的途径(优先级)：1.语言定义的声明，如this,arguments，不能在作用域内重新定义this2.形式参数3.函数声明4.var声明的变量 标识符用来识别具体对象的一个名称，最常见为变量名，以及函数名。命名规则:第一个字符可以是任意Unicode字母，$和_,第二个及以后的还可以用0-9中文可以用作标识符， js有一些保留字不能用作标识符:arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yieldInfinity NaN undefined虽然不是保留字，但因为具有特别含义，也不用作标识","tags":[{"name":"js","slug":"js","permalink":"https://sixcx.github.io/tags/js/"}]},{"title":"hexo搭建github博客的学习","date":"2017-02-14T12:09:22.000Z","path":"2017/02/14/hexo-learn/","text":"导语 使用github pages服务器搭建博客的好处:1.静态文件，访问速度快2.免费，无需花钱就能搭建一个自己的博客3.数据安全，基于github4.只需要写自己的文章上传即可5.可以随意绑定自己的域名 准备工作 自己的github账号 安装nodejs、npm，及其相关知识 安装git 创建仓库新建用户名为 username.github.io的仓库,username就是你的用户名，也必须是你的用户名，访问地址就是 http://username.github.io每个账号只能创建一个这样的可以直接访问的仓库，以后你的代码都放在这个仓库 绑定域名显然，不绑定也是可以的，如果你想有个性一点，就去注册一个域名。配置域名常见两种方式，CNAME和A记录，CNAME填域名，A记录填IP，不带www方式的只能采用A记录，先ping一下username.github.io的IP，到你的域名DNS设置页将A记录指向这个IP，将CNAME指向username.github.io，保证无论是否有www都能访问。到你项目的根目录建一个CNAME文件，填写你的域名，就可以访问这个域名，原来的默认并没有失效，只是自动调转到新域名 配置SSH key解决服务器与本机的连接问题，打开git bash执行: cd ~/.ssh #检查本机已存在的ssh密钥 提示: No such file of directory说明是第一次使用执行: ssh-keygen -t rsa -C &quot;你的邮件地址&quot; 3次回车，会生成在用户目录下，打开.ssh\\id_rsa.pub，复制内容，在你的github主页个人设置-&gt;SSH ang GPG keys-&gt;New SSH key，将内容复制进去，title随意，保存执行以下命令来测试是否成功: ssh -T git@github.com 若提示Are you sure yo want to continue connecting(yes/no)?，输入yes，成功 使用hexo简介:hexo是一个基于Github Pages的博客发布工具 官网：http://hexo.io github: https://github.com/hexojs/hexo安装： npm install -g hexo 初始化：新建一个文件夹，作为存放代码的地方 cd 你的文件夹 hexo init hexo会自动加载文件到此目录使用以下命令生成启动: hexo g #生成 hexo s #启动服务 执行后会在目录下生成public文件夹生成相关html文件，用于提交到github打开localhost:4000就会看到内容 修改主题：网上有很多，这里使用hexo-theme-yilia下载: git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 将主题放入theme文件夹下的yilia，修改根目录_config.yml的theme: landscape改为theme: yilia，执行hexo g 重新生成，遇到问题可以执行hexo clean来清理，再重新生成发布。 上传到github将_config_yml中的deploy修改: deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 安装下列插件: npm install hexo-deploy-git --save 使用git bash 输入 hexo d 将代码提交到github 可以将CNAME、README.md等文件放入source，在_config.yml中配置skip_render: [README.md] 缩写: hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令: hexo s -g #生成并本地预览 hexo d -g #生成并上传 写博客到hexo根目录执行: hexo new &apos;name&apos; hexo会帮我们在_posts下面生成相关md文件打开此文件就可以开始写博客","tags":[{"name":"github","slug":"github","permalink":"https://sixcx.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://sixcx.github.io/tags/hexo/"}]}]